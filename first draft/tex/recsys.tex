% !TeX root = ../thesis.tex

\chapter{推荐系统与协同过滤算法简介}
  \section{推荐系统的基本组成}
  在不同业务场景下，推荐系统的设计也会有所差异，但一些必要的组件是共通的。一个普通的推荐系统最主要的组成模块有下面三个：数据层、召回层和排序层。

  \begin{enumerate}
    \item 数据层：推荐系统是在做用户的行为模式挖掘，而挖掘是建立在分析用户对物品的行为数据上的，因此离不开大量数据。数据层其实是一个较为笼统的说法，其主要的功能包括了：上报业务数据、特征工程、数据拼接等等，是推荐算法的数据来源。对于用户行为数据，应尽可能地覆盖用户可能涉及到的业务流程。而对于物品相关的属性数据，也应当尽可能地覆盖更多的属性维度。在推荐系统中，“物品”一词是一种概念性的统称，对于不同的推荐业务场景，“物品”可以指代新闻、小说、音乐、电影等不同对象。用户信息和物品的信息越全，模型最后作出的推荐结果也会越准确。

    \item 召回层：通常推荐模型的计算开销会比较大，而可供推荐的物品数往往成千上万，这样完全依赖模型进行推荐的成本太高。因此设计召回策略是很必要的：将用户可能感兴趣的物品从全量的物品集中事先提取出来，作为推荐内容的候选集，模型最终为每个用户推荐的结果则是这个候选集的某个子集。候选集的大小一般不会很大。
    召回算法种类丰富，如有热门推荐、基于内容/标签等的召回、协同过滤召回、主题模型召回等等。通常来说，单一召回算法得到的结果比较难以满足业务需求，所以实际情况中往往采用多路召回的策略，即每一路召回尽量采取一个不同的策略，召回$K$条物料，$K$值可以根据各算法的实际表现来分配。

    \item 排序层：排序层针对多路召回的结果，利用排序算法进行打分和重排，以更好的反映用户的偏好。通过排序优化用户对召回集的点击行为后，将用户更可能喜欢的物品取出作为最终的推荐列表推荐给用户，提升用户体验。通常会选取模型预测打分最高的前N个物品，这也被称为TopN推荐。排序算法的种类也很丰富，比如有LR，GBDT等机器学习模型，有BPR等排序模型，还有Wide \& Deep, DNN等深度学习模型等。
  \end{enumerate}

  \section{推荐算法的分类}
  Adomavicius等人\cite{adomavicius2005toward}曾对推荐系统的问题有一个范式化的定义：设所有用户集合为$C$，所有可能被推荐的物品集合为$S$，这两个集合都可以非常大。令$u$表示一个效用函数，度量了某物品$s$对某用户$c$的价值：$u:C\times S\rightarrow R$，这里的$R$是一定区间内的非负实数。则对于用户集合$C$中的任意一个用户$c$，我们想要找到物品集合$S$中那个使得效用最大化的物品，即：
  \begin{equation}
  \forall c\in C, s_c^{'}=\mathop{argmax}_{s\in S}u(c,s).
  \end{equation}

  在推荐系统中，这个效用函数通常是一个打分函数，表示用户对物品的喜好程度。
  根据数据源或是推荐策略的不同，推荐系统算法大体上可以分成下面几大类：基于内容的推荐、基于规则的推荐、协同过滤推荐以及混合推荐。其中，协同过滤算法是目前最主流，应用也是最广泛的一类算法。
    \subsection{基于内容的推荐}
    基于内容的推荐算法（Content-based Recommendation）起源于信息检索和信息过滤研究，该方法中，效用函数$u(c,s)$是基于$u(c,s_i)$来估计的，其中$s_i\in S$表示和物品$s$相似的物品。换句话说，这种算法会推荐给用户和他过去历史上交互过、喜欢过的物品相似的物品。具体地，算法会通过对用户历史行为信息的分析，提取出可以表示这个用户的兴趣爱好的特征向量，然后计算用户特征向量与待推荐物品特征向量间的相似度，最后将和用户相似度高的物品推荐给用户\cite{lops2011content}。

    \subsection{基于规则的推荐}
    基于规则的推荐属于大众型的推荐，比如最多用户点击、最多用户收藏等等，类似那些排名榜单的推荐。这种推荐方法不属于“个性化推荐”，但是很适合应对一些冷启动问题，因为基于规则的推荐算法即使缺少某用户或是某物品的历史行为数据，也能够做出推荐结果。

    \subsection{协同过滤的推荐}
    协同过滤的推荐（Collaborative Filtering, CF）是一种利用集体智慧的推荐方法，它通过数据学习用户与物品历史上的交互交集，过滤掉一些不值得推荐的物品如评分较低的物品，或是用户曾有过交互的物品，最后把真正感兴趣的物品推荐给用户。这种方法有许多优点，比如不需要太多专业领域知识、工程易实现等，也是众多推荐算法中应用最广泛的一种算法。根据是否使用机器学习的思想，协同过滤算法可以进一步划分为基于内存的协同过滤（Memory-based CF）和基于模型的协同过滤（Model-based CF）\cite{su2009survey}两大类。
      \subsubsection{基于内存的协同过滤}
      Memory-based CF主要采用启发式的方法进行推荐，关键的步骤在于选取合适的相似度度量函数。根据维度的不同，分为基于用户的{}协同过滤（User-based CF）和基于物品的协同过滤（Item-based CF）。\cite{wang2006unifying}
      \begin{enumerate}
        \item User-based CF的思想是：当某个用户$u$需要个性化推荐的时候，寻找和他兴趣相似的其他一些用户$v_1,v_2,\ldots,v_k$，然后把这些用户喜欢的，但是该用户没有接触过的物品推荐给$u$。对于用户间的相似度计算，User-based CF采用如下简单的余弦相似度：
        \begin{equation}
        sim(u,v)=\frac{|N(u)\cap N(v)|}{\sqrt{|N(u)|\cdot|N(v)|}},
        \end{equation}
        其中记号$N(u)$表示用户$u$喜欢过的物品集合。得到了用户间的相似度矩阵后，就可以对指定用户对指定物品的感兴趣程度进行预测：
        \begin{equation}
        r_{ui} = \sum\limits_{v\in N(i)\cap B(u,k)}sim(u,v)\cdot r_{vi}.
        \end{equation}

        上式中，$B(u,k)$表示和用户$u$相似度最高的$k$个其他用户，$N(i)$是对物品$i$有过行为的用户集合，$r_{vi}$是用户$v$对物品$i$的兴趣程度。（一般是具体的打分）

        \item Item-based CF的思想是：当某个用户$u$需要个性化推荐的时候，寻找该用户历史上曾经喜欢过的物品列表$j_1,j_2,\ldots, j_n$，然后将和这些物品比较相似的其他物品推荐给用户$u$。对于物品间的相似度计算，Item-based CF的做法和User-based CF相仿：
        \begin{equation}
        sim(i,j)=\frac{|N(i)\cap N(j)|}{\sqrt{|N(i)|\cdot|N(j)|}},
        \end{equation}
        其中记号$N(i)$表示喜欢物品$i$的用户集合。得到了物品间的相似度矩阵后，就可以对指定用户对指定物品的感兴趣程度进行预测：
        \begin{equation}
        r_{ui} = \sum\limits_{j\in N(u)\cap B(i,k)}sim(i,j)\cdot r_{uj}.
        \end{equation}

        上式中，$B(i,k)$表示和物品$i$相似度最高的$k$个其他物品，$N(u)$是用户$u$喜欢过的物品集合，$r_{vi}$是用户$v$对物品$i$的兴趣程度。（一般是具体的打分）
      \end{enumerate}

      \subsubsection{基于模型的协同过滤}
      诸如机器学习、数据挖掘算法等“模型”的出现和发展，可以使得推荐系统基于训练数据学会如何识别复杂模式，进而对真实数据的协同过滤任务做出智能的预测。Model-based CF就是应用了一些机器学习的思想，常见的方法有：矩阵分解算法、分类回归算法、图算法、Bayes模型、聚类模型等等\cite{su2009survey}。

      \begin{itemize}
        \item 矩阵分解算法：将数据集变换成一个UI打分矩阵$M_{m\times n}$，共$m$行$n$列，表示$m$个用户对$n$个物品的打分情况。由于稀疏性的问题，这个UI矩阵大部分元素都等于零。这种情况下，如果能估计出矩阵的每个位置元素，就可以实现推荐预测了。以简单但有效的FunkSVD算法\cite{funk2006netflix}为例，我们期望将UI矩阵$M$进行分解：
        \begin{equation}
        M_{m\times n}=P^T_{m\times k}Q_{k\times n}.
        \end{equation}

        对于每一个元素$m_{ij}$，通过矩阵分解后的对应表示应该是：
        \begin{equation}
        m_{ij} = e_i^TP^TQe_j = p_i^Tq_j,
        \end{equation}
      
        用均方差作为损失函数，对于全部的用户和物品组合，我们期望最小化的目标函数就是：
        \begin{equation}
        \mathop{argmin}_{p_i,q_j}\sum_{i,j}\big(m_{ij}-p_i^Tq_j\big)^2.
        \end{equation}

        通过最优化上式，得到分解的矩阵$P,Q$，进而用于推荐预测。

        \item 分类回归算法：把推荐问题转化成传统的机器学习分类/回归问题解决，前者输出概率值并根据概率大小排序推荐；后者预测用户对物品的打分，根据打分高低排序推荐。
      \end{itemize}

      \subsubsection{协同过滤方法的优缺点}
      文献\cite{su2009survey}已经对两大类协同过滤方法各自的优点与缺点有了总结。对于Memory-based CF，其主要优点有易实现性、无需考虑推荐物品的具体内容、容易添加新数据；缺点主要是对稀疏数据敏感、难以应对冷启动问题等。而对于Model-based CF，其主要优点是对稀疏数据不敏感、改善了模型效果；缺点是建立模型的开销较大、在预测表现和可扩展性之间有一个权衡、一些降维算法会损失信息。

    \subsection{混合推荐}
    混合推荐（Hybrid RS），是将协同过滤的推荐和基于内容的推荐结合在一起，这种方法可以帮助避免使用单一类推荐算法所遇到的限制或局限性。例如，基于内容的推荐算法偏好给用户推荐与其历史上喜好类似的物品，这样会导致推荐结果缺乏一定的新颖性；协同过滤推荐在遇到冷启动问题，以及数据稀疏、维度灾难等问题时会比较麻烦等。而如果把这几种算法组合到一种推荐算法中去，就可以取长补短，充分利用各自的优势。常见的混合推荐实现类型有\cite{burke2002hybrid}：
    \begin{itemize}
      \item Weighted：给予每种算法一个权重，最后混合来推荐单独的一个物品
      \item Switching：根据不同场景，系统自动在不同的推荐算法之间选择
      \item Mixed：把不同推荐算法得到的推荐结果，放在一起一同展示给用户
      \item Feature combination：将不同推荐算法产生的数据特征组合在一起作为新的特征
    \end{itemize}

  \section{推荐系统的评价指标}
  这里主要讨论实际应用中常见的TopN推荐（后文实验中也是TopN推荐）。记系统对用户$u$推荐的$N$个物品组成的列表为$R(u)$，用户$u$在测试集上实际喜欢的物品组成的集合为$T(u)$，测试集全体用户集合为$\tilde{U}$。下面列出了在后文中用到的一些评价指标\cite{2012推荐系统实践}：
  \begin{itemize}
    \item 精确率：
    \begin{equation}
    Precision = \frac{\sum\limits_{u\in\tilde{U}}|T(u)\cap R(u)|}{\sum\limits_{u\in\tilde{U}}|R(u)|},
    \end{equation}
    
    \item 召回率：
    \begin{equation}
    Recall = \frac{\sum\limits_{u\in\tilde{U}}|T(u)\cap R(u)|}{\sum\limits_{u\in\tilde{U}}|T(u)|},
    \end{equation}

    \item 准确率(命中率)：
    \begin{equation}
    Hit\;rate=\frac{\sum\limits_{u\in\tilde{U}}1_{\{T(u)\cap R(u) \neq\emptyset\}}}{|\tilde{U}|},
    \end{equation}

    \item 覆盖率：
    \begin{equation}
    Coverage = \frac{\big|\cup_{u\in\tilde{U}}R(u)\big|}{|I|}.
    \end{equation}
    
  \end{itemize}

  类比机器学习中二分类问题的评价指标，在TopN推荐中，也有对应的精确率（Precision）和召回率（Recall）。精确率体现了结果推荐列表中有多少比例的物品的确被用户产生了行为；而召回率体现了被用户实际产生行为的物品中有多少比例被包含在了最终的推荐结果中。除精确率和召回率以外，命中率类似$Accuracy$，这里作为一个辅助指标；覆盖率可以反映算法挖掘长尾的能力，所谓长尾效应指的就是小部分的物品占据了大部分的流量，而剩余大部分的物品所处的区域就被称为长尾区域。长尾效应中的主体部分体现的是共性数据，这部分数据很容易被挖掘利用；而长尾部分则是个性化数据的体现\cite{曾洋2017基于电商的长尾推荐的研究与实现}。如果推荐算法的覆盖率越高，说明算法越能够将长尾中的物品推荐给用户，而不仅仅是集中推荐热门的共性物品。
